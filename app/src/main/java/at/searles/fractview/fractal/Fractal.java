package at.searles.fractview.fractal;

import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import at.searles.fractview.AssetsHelper;
import at.searles.fractview.Commons;
import at.searles.math.Cplx;
import at.searles.math.Scale;
import at.searles.math.color.Palette;
import at.searles.meelan.CompileException;
import at.searles.meelan.ExternalData;
import at.searles.meelan.Meelan;
import at.searles.meelan.Op;
import at.searles.meelan.ScopeTable;
import at.searles.meelan.Tree;
import at.searles.meelan.Value;
import at.searles.parsing.ParsingError;

/*
 * When parsing, an instance of ExternData is created.
 * Additionally, there is a Map of custom parameters.
 *
 * So, ExternData gets a list of parameters, with
 * a type and a default value. The order must
 * be preserved.
 *
 * Parameter also contains data type. Order of parameters
 * is of no importance.
 *
 * LinkedHashMap<String, ExternElement>
 */

public class Fractal implements Parcelable, ExternalData {

	/**
	 * Scale of this fractal
	 */
	private Scale scale;

	/**
	 * Source code of the program
	 */
	private String sourceCode;

	/**
	 * Replacements for default data
	 */
	private Map<String, Parameter> data;

    /**
     * Default data in the order in which they are added.
     * This map is created when the source code is parsed.
     */
    private transient LinkedHashMap<String, Parameter> defaultData = null;

    /**
	 * Abstract Syntax Tree, generated by parse method
	 */
	private transient Tree ast = null; // generated

	/**
	 * Byte code, generated by compile method
	 */
	private transient int[] code = null; // generated

	/**
	 * Simple constructor
	 * @param scale
	 * @param sourceCode
	 * @param parameters
	 */
	public Fractal(Scale scale, String sourceCode, Map<String, Parameter> parameters) {
		if(scale == null || sourceCode == null || parameters == null) {
			throw new NullPointerException();
		}

		this.scale = scale;
		this.sourceCode = sourceCode;
		this.data = parameters;
	}

	/**
	 * Returns an iterable of all parameters.
	 * @return
	 */
	public Iterable<String> parameters() {
		if(defaultData == null) throw new IllegalArgumentException("parse has not been called yet!");
		return defaultData.keySet();
	}

	/**
	 * @param id The name of the parameter
	 * @return true if the parameter with the given name is a member of data.
	 */
	public boolean isDefault(String id) {
		if(defaultData == null) {
			throw new IllegalArgumentException("parse has not been called yet!");
		} else if (!defaultData.containsKey(id)) {
			throw new IllegalArgumentException("id " + id + " is not a valid parameter");
		} else {
			// Types must be identical
			// FIXME FIXME
			return (data.containsKey(id) && data.get(id).type == defaultData.get(id).type);
		}
	}

	/**
	 * Returns the value for a given parameter
	 * @param id
	 * @return
	 */
	public Parameter get(String id) {
		if(isDefault(id)) {
			return data.get(id);
		} else {
			return defaultData.get(id);
		}
	}

	/**
	 * Resets parameter with id to default
	 * @param id
	 */
	public void setToDefault(String id) {
		data.remove(id);
	}

	/**
	 * Scale requires special treatment.
	 */
	public void setScaleToDefault() {
		setScale(AssetsHelper.DEFAULT_SCALE);
	}

	/**
	 * Resets all parameters to default
	 */
	public void setAllToDefault() {
		setScaleToDefault();
		data.clear();
	}

	public void setInt(String id, int i) {
		data.put(id, new Parameter(Type.Int, i));
	}

	public void setReal(String id, double d) {
		data.put(id, new Parameter(Type.Real, d));
	}

	public void setCplx(String id, Cplx c) {
		data.put(id, new Parameter(Type.Cplx, c));
	}

	public void setBool(String id, boolean b) {
		data.put(id, new Parameter(Type.Bool, b));
	}

	public void setExpr(String id, String expr) {
		data.put(id, new Parameter(Type.Expr, expr));
	}

	public void setColor(String id, int color) {
		data.put(id, new Parameter(Type.Color, color));
	}

	public void setPalette(String id, Palette p) {
		data.put(id, new Parameter(Type.Palette, p));
	}

	/**
	 * Create a new instance of this class with a different source code
	 * @param newSourceCode the new source code
	 * @param reuseArguments if true, old arguments are reused.
	 * @return fractal with the new source code
	 */
	public Fractal copyNewSource(String newSourceCode, boolean reuseArguments) {
		// This one requires complete new compiling
		return new Fractal(scale, newSourceCode, reuseArguments ? data : new HashMap<>());
	}

	/**
	 * Creates a copy of this fractal with new scale.
	 * @param newScale
	 * @return
	 */
	public Fractal copyNewScale(Scale newScale) {
		Fractal f = new Fractal(newScale, sourceCode, data);

		// take over generated stuff.
		f.defaultData = defaultData; f.ast = ast; f.code = code;

		return f;
	}

	/**
	 * Creates a copy of this fractal with new data.
	 * @param newData
	 * @return
	 */
	public Fractal copyNewData(Map<String, Parameter> newData) {
		Fractal f = new Fractal(scale, sourceCode, newData);

		// take over generated stuff.
		f.defaultData = defaultData; f.ast = ast; f.code = code;

		return f;
	}
	/**
	 * Returns a new Fractal object that is a merged one of
	 * other and this. If there is an element in both of them, then
	 * the one of 'this' is used.
	 * @param that the other fractal
	 * @return a new object
	 */
	public Fractal mergeData(Fractal that) {
		Map<String, Parameter> mergedData = Commons.merge(this.data, that.data);

		return copyNewData(mergedData);
	}
	// The fractal is described by the following three elements:


	// some mutable methods
	public Scale scale() {
		return scale;
	}

	public void setScale(Scale scale) {
		this.scale = scale;
	}

	/**
	 * Since palettes must be transferred directly to the script, convenience method
	 * to collect all palettes
	 * @return
	 */
	public List<Palette> palettes() {
		// Collect all palettes
		LinkedList<Palette> list = new LinkedList<>();

		for(String id : parameters()) {
			Parameter p = get(id);
			if(p.type == Type.Palette) {
				list.add((Palette) p.object);
			}
		}

		return list;
	}

	public String sourceCode() {
		return sourceCode;
	}

	public int[] code() {
		return code;
	}


	/**
	 * Parses the source code and thus collects
	 * default parameters.
	 * @throws ParsingError
	 * @throws CompileException
	 */
	public void parse() throws ParsingError, CompileException {
		defaultData = new LinkedHashMap<>();
		ast = Meelan.parse(sourceCode, this);
		Log.d("FR", ast.toString());
	}

	/**
	 * Compiles the source code, replacing
	 * the default parameters by custom parameters.
	 * @throws ParsingError
	 * @throws CompileException
	 */
	public void compile() throws ParsingError, CompileException {
		if(defaultData == null) parse();

		// all parameters are added to the scope table.
		ScopeTable table = new ScopeTable();

		// For palettes there are some treats here:
		// A palette is actually a function with one complex argument.
		Tree.Id xy = new Tree.Id("__xy");

		int paletteIndex = 0; // and we count the number of them.

		for(String id : parameters()) {
			Parameter p = get(id);

			switch(p.type) {
				case Int:
					table.addDef(id, new Value.Int(((Number) p.object).intValue()));
					break;
				case Real:
					table.addDef(id, new Value.Real(((Number) p.object).doubleValue()));
					break;
				case Cplx:
					table.addDef(id, new Value.CplxVal((Cplx) p.object));
					break;
				case Bool:
					table.addDef(id, new Value.Bool((Boolean) p.object));
					break;
				case Expr:
					try {
						// extern values must be treated special
						// unless they are constants.
						table.addExtern(id, Meelan.parse((String) p.object, null));
					} catch(ParsingError e) {
						throw new CompileException(e.getMessage());
					}
					break;
				case Color:
					table.addDef(id, new Value.Int((Integer) p.object));
					break;
				case Palette:
					// Palettes are special
					// A palette is actually a function with one complex argument.
					// this one defines a function
					Tree.FuncDef fn = new Tree.FuncDef("palette_" + id, Collections.singletonList("__xy"),
							Op.__ld_palette.eval(Arrays.asList(new Value.Label(paletteIndex), xy)));

					table.addDef(id, fn);
					paletteIndex++;

					break;
			}
		}

		this.code = Meelan.compile(ast, table);
	}

	@Override
	public int describeContents() {
		return 0;
	}

	@Override
	public void writeToParcel(Parcel parcel, int flags) {
		// First source code
		parcel.writeString(sourceCode);

		// Next scale
		parcel.writeDouble(scale.xx());
		parcel.writeDouble(scale.xy());
		parcel.writeDouble(scale.yx());
		parcel.writeDouble(scale.yy());
		parcel.writeDouble(scale.cx());
		parcel.writeDouble(scale.cy());

		// Next data.
		parcel.writeInt(data.size());

		for(Map.Entry<String, Parameter> entry : data.entrySet()) {
			parcel.writeString(entry.getKey());

			Type type = entry.getValue().type;
			Object o = entry.getValue().object;

			parcel.writeInt(type.ordinal());

			switch(type) {
				case Int:
					parcel.writeInt((Integer) o);
					break;
				case Real:
					parcel.writeDouble((Double) o);
					break;
				case Cplx:
					parcel.writeDouble(((Cplx) o).re());
					parcel.writeDouble(((Cplx) o).im());
					break;
				case Bool:
					parcel.writeInt((Boolean) o ? 1 : 0);
					break;
				case Expr:
					parcel.writeString((String) o);
					break;
				case Color:
					parcel.writeInt((Integer) o);
					break;
				case Palette:
					Commons.writePaletteToParcel((Palette) o, parcel);
					break;
				default:
					throw new IllegalArgumentException("Did not expect " + type + " in 'data'");
			}
		}
	}

	private static final String SCALE_LABEL = "scale";
	private static final String SOURCE_LABEL = "source";

	private static final String INTS_LABEL = "ints";
	private static final String REALS_LABEL = "reals";
	private static final String CPLXS_LABEL = "cplxs";
	private static final String BOOLS_LABEL = "bools";
	private static final String EXPRS_LABEL = "exprs";
	private static final String COLORS_LABEL = "colors";
	private static final String PALETTES_LABEL = "palettes";
	private static final String SCALES_LABEL = "scales";

	private static final String DATA_LABEL = "arguments";

	/**
	 * Custom serializer for fractal. Mainly for historic reasons - when this app was implemented
	 * the first time, elements were grouped by type.
	 * @return
	 */
	public JsonElement serialize() {
		JsonObject ret = new JsonObject();

		// Scale is stored as double-array
		ret.add(SCALE_LABEL, scale.serialize());

		JsonArray sourceArray = new JsonArray();

		for(String line : sourceCode.split("\n")) {
			sourceArray.add(line);
		}

		ret.add(SOURCE_LABEL, sourceArray);

		JsonObject ints = new JsonObject();
		JsonObject reals = new JsonObject();
		JsonObject cplxs = new JsonObject();
		JsonObject bools = new JsonObject();
		JsonObject exprs = new JsonObject();
		JsonObject colors = new JsonObject();
		JsonObject palettes = new JsonObject();
		JsonObject scales = new JsonObject();

		for(String id : parameters()) {
			if(!isDefault(id)) {
				Parameter element = data.get(id);

				switch (element.type) {
					case Int:
						ints.addProperty(id, (Integer) element.object);
						break;
					case Real:
						reals.addProperty(id, (Double) element.object);
						break;
					case Cplx:
						cplxs.add(id, ((Cplx) element.object).serialize());
						break;
					case Bool:
						bools.addProperty(id, (Boolean) element.object);
						break;
					case Expr:
						exprs.addProperty(id, (String) element.object);
						break;
					case Color:
						colors.addProperty(id, (Integer) element.object);
						break;
					case Palette:
						palettes.add(id, ((Palette) element.object).serialize());
						break;
					case Scale:
						scales.add(id, ((Scale) element.object).serialize());
						break;
				}
			}
		}

		JsonObject data = new JsonObject();

		if(!ints.entrySet().isEmpty()) data.add(INTS_LABEL, ints);
		if(!reals.entrySet().isEmpty()) data.add(REALS_LABEL, reals);
		if(!cplxs.entrySet().isEmpty()) data.add(CPLXS_LABEL, cplxs);
		if(!bools.entrySet().isEmpty()) data.add(BOOLS_LABEL, bools);
		if(!exprs.entrySet().isEmpty()) data.add(EXPRS_LABEL, exprs);
		if(!colors.entrySet().isEmpty()) data.add(COLORS_LABEL, colors);
		if(!palettes.entrySet().isEmpty()) data.add(PALETTES_LABEL, palettes);
		if(!scales.entrySet().isEmpty()) data.add(SCALES_LABEL, scales);

		if(!data.entrySet().isEmpty()) ret.add(DATA_LABEL, data);

		return ret;
	}

	public static Fractal deserialize(JsonElement element) {
		// Scale is stored as double-array
		JsonObject obj = (JsonObject) element;

		Scale scale = Scale.deserialize(obj.get(SCALE_LABEL));

		StringBuilder sourceCode = new StringBuilder();
		JsonArray sourceArray = obj.getAsJsonArray(SOURCE_LABEL);

		for(JsonElement line : sourceArray) {
			sourceCode.append(line.getAsString()).append('\n');
		}

		// Fetch data.
		Map<String, Parameter> dataMap = new HashMap<>();

		JsonObject data = obj.getAsJsonObject(DATA_LABEL);

		if(data != null) {
			// all of them are optional.
			JsonObject ints = data.getAsJsonObject(INTS_LABEL);
			JsonObject reals = data.getAsJsonObject(REALS_LABEL);
			JsonObject cplxs = data.getAsJsonObject(CPLXS_LABEL);
			JsonObject bools = data.getAsJsonObject(BOOLS_LABEL);
			JsonObject exprs = data.getAsJsonObject(EXPRS_LABEL);
			JsonObject colors = data.getAsJsonObject(COLORS_LABEL);
			JsonObject palettes = data.getAsJsonObject(PALETTES_LABEL);
			JsonObject scales = data.getAsJsonObject(SCALES_LABEL);

			if (ints != null) for(Map.Entry<String, JsonElement> entry : ints.entrySet()) {
				dataMap.put(entry.getKey(), new Fractal.Parameter(Type.Int, entry.getValue().getAsInt()));
			}

			if (reals != null) for(Map.Entry<String, JsonElement> entry : reals.entrySet()) {
				dataMap.put(entry.getKey(), new Parameter(Type.Real, entry.getValue().getAsDouble()));
			}

			if (cplxs != null) for(Map.Entry<String, JsonElement> entry : cplxs.entrySet()) {
				dataMap.put(entry.getKey(), new Parameter(Type.Cplx, Cplx.deserialize(entry.getValue())));
			}

			if (bools != null) for(Map.Entry<String, JsonElement> entry : bools.entrySet()) {
				dataMap.put(entry.getKey(), new Parameter(Type.Bool, entry.getValue().getAsBoolean()));
			}

			if (exprs != null) for(Map.Entry<String, JsonElement> entry : exprs.entrySet()) {
				dataMap.put(entry.getKey(), new Parameter(Type.Expr, entry.getValue().getAsString()));
			}

			if (colors != null) for(Map.Entry<String, JsonElement> entry : colors.entrySet()) {
				dataMap.put(entry.getKey(), new Parameter(Type.Color, entry.getValue().getAsInt()));
			}

			if (palettes != null) for(Map.Entry<String, JsonElement> entry : palettes.entrySet()) {
				dataMap.put(entry.getKey(), new Parameter(Type.Palette, Palette.deserialize(entry.getValue())));
			}

			if (scales != null) for(Map.Entry<String, JsonElement> entry : scales.entrySet()) {
				dataMap.put(entry.getKey(), new Parameter(Type.Scale, Scale.deserialize(entry.getValue())));
			}
		}

		return new Fractal(scale, sourceCode.toString(), dataMap);
	}

	public static final Parcelable.Creator<Fractal> CREATOR =
		new Parcelable.Creator<Fractal>() {
			public Fractal createFromParcel(Parcel in) {
				String sourceCode = in.readString();

				double xx = in.readDouble();
				double xy = in.readDouble();
				double yx = in.readDouble();
				double yy = in.readDouble();
				double cx = in.readDouble();
				double cy = in.readDouble();

				Scale sc = new Scale(xx, xy, yx, yy, cx, cy);

				Map<String, Parameter> data = new HashMap<>();

				for(int size = in.readInt(); size > 0; --size) {
					String id = in.readString();

					Type type = Type.values()[in.readInt()];

					switch(type) {
						case Int:
						case Color: // Fall though
							data.put(id, new Parameter(type, in.readInt()));
							break;
						case Real:
							data.put(id, new Parameter(type, in.readDouble()));
							break;
						case Cplx: {
							double re = in.readDouble();
							double im = in.readDouble();
							data.put(id, new Parameter(type, new Cplx(re, im)));
						} break;
						case Bool:
							data.put(id, new Parameter(type, in.readInt() == 1));
							break;
						case Expr:
							data.put(id, new Parameter(type, in.readString()));
							break;
						case Palette: {
							data.put(id, new Parameter(type, Commons.readPalette(in)));
						} break;
						default:
							throw new IllegalArgumentException("Did not expect " + type + " in 'data'");
					}

				}

				return new Fractal(sc, sourceCode, data);
			}

			public Fractal[] newArray(int size) {
				return new Fractal[size];
			}
		};


	@Override
	public void add(String id, String type, Tree init) throws CompileException {
		switch(type) {
			case "int": {
				int i = 0;
				if(init instanceof Value.Int) {
					i = ((Value.Int) init).value;
				} else if(init instanceof Value.Real) {
					// fixme this is a fix for a bug.
					i = (int) ((Value.Real) init).value;
					Log.e("FRACTALS", "An int was parsed as a real");
				} else {
					throw new CompileException("extern " + id + " = " + init + " is not an int but a " + init.getClass() + "!");
				}

				defaultData.put(id, new Parameter(Type.Int, i));
			} break;
			case "real": {
				double d = 0.0;
				if(init instanceof Value.Int) {
					d = ((Value.Int) init).value;
				} else if(init instanceof Value.Real) {
					d = ((Value.Real) init).value;
				} else {
					throw new CompileException("extern " + id + " = " + init + " is not a real but a " + init.getClass() + "!");
				}

				defaultData.put(id, new Parameter(Type.Real, d));
			} break;
			case "cplx": {
				Cplx c;
				if(init instanceof Value.Int) {
					c = new Cplx(((Value.Int) init).value);
				} else if(init instanceof Value.Real) {
					c = new Cplx(((Value.Real) init).value);
				} else if(init instanceof Value.CplxVal) {
					c = ((Value.CplxVal) init).value;
				} else {
					throw new CompileException("extern " + id + " = " + init + " is not a cplx but a " + init.getClass() + "!");
				}

				defaultData.put(id, new Parameter(Type.Cplx, c));
			} break;
			case "bool": {
				if(init instanceof Value.Bool) {
					defaultData.put(id, new Parameter(Type.Bool, ((Value.Bool) init).value));
				} else {
					throw new CompileException("extern " + id + " = " + init + " is not a bool but a " + init.getClass() + "!");
				}
			} break;
			case "expr": {
				if(init instanceof Value.StringVal) {
					defaultData.put(id, new Parameter(Type.Expr, ((Value.StringVal) init).value));
				} else {
					throw new CompileException("extern " + id + " = " + init + " is not an expr but a " + init.getClass() + "!");
				}
			} break;
			case "color": {
				// again, this one is an integer
				if(init instanceof Value.Int) {
					defaultData.put(id, new Parameter(Type.Color, ((Value.Int) init).value));
				} else {
					throw new CompileException("extern " + id + " = " + init + " is not a color but a " + init.getClass() + "!");
				}
			} break;
			case "palette": {
				// this one is a bit different
				defaultData.put(id, new Parameter(Type.Palette, Commons.toPalette(init)));
			} break;
			default:
				throw new CompileException("Unknown extern type: " + type + " for id " + id);
		}
	}

	public Map<String, Parameter> parameterMap() {
		return data;
	}

	public static class ParameterMapBuilder {
		private final Map<String, Parameter> map;


		public ParameterMapBuilder() {
			this.map = new HashMap<>();
		}

		public ParameterMapBuilder add(String key, Fractal.Type type, Object value) {
			map.put(key, new Parameter(type, value));
			return this;
		}

		public Map<String, Parameter> map() {
			return map;
		}
	}

	public static ParameterMapBuilder parameterBuilder() {
		return new ParameterMapBuilder();
	}

	/**
	 * Types of parameters. Scale is a special case because
	 * it should not be part of Parameters.
	 */
	public enum Type { Int, Real, Cplx, Bool, Expr, Color, Palette, Scale };

	public static class Parameter {
		private final Type type;
		private final Object object;

		public Parameter(Type type, Object object) {
			this.type = type;
			this.object = object;
		}

		public Type type() {
			return type;
		}

		public Object value() {
			return object;
		}
	}
}
