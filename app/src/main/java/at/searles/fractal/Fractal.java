package at.searles.fractal;

import android.os.Bundle;

import java.util.LinkedList;
import java.util.List;

import at.searles.fractal.android.BundleAdapter;
import at.searles.math.Scale;
import at.searles.math.color.Palette;
import at.searles.meelan.MeelanException;
import at.searles.meelan.compiler.Ast;
import at.searles.meelan.optree.Tree;
import at.searles.meelan.parser.MeelanEnv;
import at.searles.meelan.symbols.ExternData;
import at.searles.parsing.lexer.TokStream;
import at.searles.parsing.parser.ParserStream;

/*
 * When parsing, an instance of ExternData is created.
 * Additionally, there is a Map of custom parameters.
 *
 * So, ExternData gets a list of parameters, with
 * a type and a default  The order must
 * be preserved.
 *
 * Parameter also contains data type. Order of parameters
 * is of no importance.
 *
 * LinkedHashMap<String, ExternElement>
 */

public class Fractal {

	private static final String SOURCE_LABEL = "source";
	private static final String DATA_LABEL = "data";

	/**
	 * data contains a label Scale that contains the scale of the fractal.
	 */
	public static final String SCALE_KEY = "Scale";

    /**
     * Scale to fall back if there is no other scale defined.
     */ 
    public static final Scale DEFAULT_SCALE = new Scale(2, 0, 0, 2, 0, 0);

	/**
	 * Source code of the program.
	 */
	private final String sourceCode;

	/**
	 * Abstract Syntax Tree
	 */
	private transient Ast ast;

	/**
     * Default data in the order in which they are added.
     * This map is created when the source code is parsed.
     */
    private final ExternData data;

	/**
	 * Byte code, generated by compile method
	 */
	private final int[] code = null;

	/**
	 * Simple constructor
	 * @param sourceCode
	 * @param parameters
	 */
	private Fractal(String sourceCode, Ast ast, ExternData parameters) {
		if(sourceCode == null || parameters == null || ast == null) {
			throw new NullPointerException();
		}

		this.sourceCode = sourceCode;
		this.ast = ast;
		this.data = parameters;
	}


	public static Fractal fromValues(String sourceCode, ExternData data) {
		return fromValues(sourceCode, parseSource(sourceCode), data);
	}

	public static Fractal fromValues(String sourceCode, Ast ast, ExternData data) {
		// Use this if this fractal shares the source code with
		// other fractals.
		return new Fractal(sourceCode, ast, data);
	}

	public ExternData data() {
		return data;
	}

	public Bundle toBundle() {
		Bundle bundle = new Bundle();
		bundle.putString(SOURCE_LABEL, sourceCode());

		bundle.putBundle(DATA_LABEL, BundleAdapter.dataToBundle(data()));

		return bundle;
	}

	public static Fractal fromBundle(Bundle bundle) {
		String sourceCode = bundle.getString(SOURCE_LABEL);
		ExternParameters data = new ExternParameters();

		Bundle dataBundle = bundle.getBundle(DATA_LABEL);

		if(dataBundle != null) {
			BundleAdapter.bundleToData(dataBundle, data);
		}

		return Fractal.fromValues(sourceCode, data);
	}

    // ======== Some convenience methods to obtain data ========
    
	public Scale scale() {
		return (Scale) data.get(SCALE_KEY).get();
	}

	/**
	 * Since palettes must be transferred directly to the script, convenience method
	 * to collect all palettes
	 * @return
	 */
	public Iterable<Palette> palettes() {
		// Collect all palettes
		LinkedList<Palette> list = new LinkedList<>();

		for(ExternData.Entry entry : data.entriesOfType(Type.Palette.identifier)) {
			list.add((Palette) entry.get());
		}

		return list;
	}

	public List<Scale> scales() {
		// Collect all scales
		LinkedList<Scale> list = new LinkedList<>();

		for(ExternData.Entry entry : data.entriesOfType(Type.Scale.identifier)) {
			list.add((Scale) entry.get());
		}

		return list;
	}

	public String sourceCode() {
		return sourceCode;
	}

	public int[] code() {
		return code;
	}
}
